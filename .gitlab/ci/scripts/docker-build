#!/bin/bash
# shellcheck disable=SC2001
set -e

# set DEBUG var to any vairable to enable debugging
if [[ $DEBUG != "" ]]; then
  echo "warning: Debugging for docker-build is enabled."
  set -x
fi

if [[ $1 == "" ]] || [[ $2 == "" ]]; then
  echo "Usage: $0 CONTEXT_DIR/CONTEXT_DOCKERFILE IMAGE_REPO"
  echo
  echo "For example:"
  echo "  If your Dockerfile is on dart/Dockerfile and your context directory is dart",
  echo "  then use dart/Dockerfile as the first argument and image tag name for pushing finished."
  echo "  builds to an image registry, by default its Quay.io for both image builds and build artifacts."
  echo
  echo "Needed dependencies: uuidgen (uuid-runtime), sed, grep, basename and dirname and any tool that can build images"
  echo "from an Dockerfile Since this script will set DOCKER_BUILDKIT=1 only during docker build invocation, this requires"
  echo "Docker daemon to be running and the official Docker CLI installed beforehand."
  echo
  echo "Supported environment variables:"
  echo "  IMAGE_ARTIFACTS_REPO       Container image repo for artifacts that this script will be using for"
  echo "                             storing image artifacts to an container registry instead of the regular"
  echo "                             GitLab job artifacts."
  echo "  IMAGE_ARTIFACTS_PUSH       Set it to false to disable pushing build artifacts to an container registry."
  echo "                             You can push them at a later date."
  echo "  SKIP_DOCKER_PUSH           Skip pushing images to container registry, which passed to the publish-image"
  echo "                             utility script."
  echo "  CI_PROJECT_PATH_SLUG       GitLab project path slug. Use the clone web URl of your project as an reference,"
  echo "                             minus the GitLab hostname."
  exit 2
fi

# script params
DIR=$(dirname "$1")
DOCKERFILE=$(basename "$1")
IMAGE_NAME=$2
CUSTOM_TAG=$3 # Will be implemented soon

# if we're inside GitLab CI with these variables, use CI_COMMIT_REF_SLUG var instead
if [[ $GITLAB_CI == "true" ]]; then
  GIT_BRANCH=$CI_COMMIT_REF_SLUG
else
  GIT_BRANCH="$(git rev-parse --abbrev-ref HEAD | sed 's_/_-_g')"
fi

BUILD_ID="ci-build-$GIT_BRANCH"
# Check your distro's package name for uuidgen/uuid-runtime at https://pkgs.org/search/?q=uuid
ARTIFACT_ID="$(uuidgen)"
# Image artifact repository to store build artifacts
IMAGE_ARTIFACTS_REPO=${IMAGE_ARTIFACTS_REPO:-"quay.io/gitpodified-workspace-images/build-artifacts"}
REPO_SLUG=$CI_PROJECT_PATH_SLUG

pushArtifact() {
  echo "========== Pushing build artifact to $IMAGE_ARTIFACTS_REPO =========="
  docker tag "$IMAGE_NAME:$BUILD_ID" "$IMAGE_ARTIFACTS_REPO:$ARTIFACT_ID"
  docker tag "$IMAGE_NAME:$BUILD_ID" "$IMAGE_ARTIFACTS_REPO:gl-$REPO_SLUG-mr-$CI_MERGE_REQUEST_IID"
  # added "|| true" to ensure CI builds don't complain about it
  ./.gitlab/ci/scripts/publish-image "$IMAGE_ARTIFACTS_REPO:$ARTIFACT_ID" "$IMAGE_ARTIFACTS_REPO:gl-$REPO_SLUG-mr-$CI_MERGE_REQUEST_IID" || true
}

echo "========== Docker BuildKit starts in 10 seconds =========="
DOCKER_BUILDKIT=1 docker build --tag "$IMAGE_NAME:$BUILD_ID" --file "$DIR/$DOCKERFILE" "$DIR"

# If $2 is blank, it will be only available as an build artifact in IMAGE_ARTIFACTS_REPO, like
# in merge request builds.
if [[ $CI_PIPELINE_SOURCE == "merge_request_event" || $IMAGE_NAME == ""  ]]; then
  pushArtifact
else
  pushArtifact
  echo "========== Deploying image to RHQCR =========="
  if [[ $GIT_BRANCH != "recaptime-dev-mainline" ]]; then
     docker tag "$IMAGE_NAME:$BUILD_ID" "$IMAGE_NAME:branch-$GIT_BRANCH"
     docker push "$IMAGE_NAME:branch-$GIT_BRANCH"
  elif [[ $GIT_BRANCH == "recaptime-dev-mainline" && $IMAGE_NAME != "" && $CUSTOM_TAG == "" ]]; then
     docker tag "$IMAGE_NAME:$BUILD_ID" "$IMAGE_NAME:latest"
     docker push "$IMAGE_NAME:latest"
  fi
fi
